#!/usr/bin/env python3
"""
Multimedia Integration Test Suite
Comprehensive testing of all multimedia services with TDD methodology
"""

import pytest
import numpy as np
import time
import json
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", ".."))

from src.services.multimedia.media_processor_service import MediaProcessorService
from src.services.multimedia.content_management_service import ContentManagementService
from src.services.multimedia.streaming_service import StreamingService


class TestMultimediaIntegration:
    """Integration test suite for multimedia services"""

    @pytest.fixture
    def media_processor(self):
        """Create a fresh MediaProcessorService instance"""
        return MediaProcessorService()

    @pytest.fixture
    def content_manager(self):
        """Create a fresh ContentManagementService instance"""
        return ContentManagementService()

    @pytest.fixture
    def streaming_service(self):
        """Create a fresh StreamingService instance"""
        return StreamingService()

    @pytest.fixture
    def mock_frame(self):
        """Create a mock video frame for testing"""
        return np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)

    @pytest.fixture
    def mock_audio_data(self):
        """Create mock audio data for testing"""
        return np.random.randint(-32768, 32767, 1024, dtype=np.int16)

    def test_media_processor_initialization(self, media_processor):
        """Test MediaProcessorService initialization"""
        assert media_processor.video_service is not None
        assert media_processor.audio_service is not None
        assert media_processor.processing_pipelines == {}
        assert media_processor.effect_chains == {}
        assert media_processor.is_processing == False

    def test_content_manager_initialization(self, content_manager):
        """Test ContentManagementService initialization"""
        assert content_manager.content_pipelines == {}
        assert content_manager.content_templates == {}
        assert content_manager.auto_blogger_config["enabled"] == True
        assert content_manager.content_cache == {}

    def test_streaming_service_initialization(self, streaming_service):
        """Test StreamingService initialization"""
        assert streaming_service.streaming_sessions == {}
        assert streaming_service.content_schedules == {}
        assert streaming_service.streaming_config["max_streams"] == 5
        assert streaming_service.streaming_config["default_quality"] == "720p"

    def test_multimedia_pipeline_creation(self, media_processor):
        """Test multimedia pipeline creation and management"""
        # Create pipeline configuration
        pipeline_config = {
            "name": "test_pipeline",
            "type": "multimedia",
            "enable_video": True,
            "enable_audio": True,
            "video": {"device_id": 0},
            "audio": {"device_id": 0},
            "video_effects": [{"type": "grayscale"}],
            "audio_effects": [{"type": "normalize"}],
        }

        # Start pipeline
        result = media_processor.start_multimedia_pipeline(
            "test_pipeline", pipeline_config
        )
        assert result == True

        # Check pipeline status
        status = media_processor.get_pipeline_status("test_pipeline")
        assert status["name"] == "test_pipeline"
        assert status["status"] == "active"

        # Stop pipeline
        result = media_processor.stop_multimedia_pipeline("test_pipeline")
        assert result == True

    def test_content_pipeline_creation(self, content_manager):
        """Test content pipeline creation and execution"""
        # Create content pipeline
        pipeline_config = {
            "name": "blog_pipeline",
            "type": "blog",
            "source": "multimedia",
            "output_format": "markdown",
        }

        result = content_manager.create_content_pipeline(
            "blog_pipeline", pipeline_config
        )
        assert result == True

        # Start content generation
        source_data = {
            "title": "Test Blog Post",
            "description": "A test blog post generated by Auto Blogger",
            "tags": ["test", "automation", "ai"],
            "category": "technology",
            "key_points": ["Point 1", "Point 2", "Point 3"],
            "summary": "This is a test summary.",
        }

        result = content_manager.start_content_generation("blog_pipeline", source_data)
        assert result == True

        # Wait for generation to complete
        time.sleep(0.1)

        # Check pipeline status
        status = content_manager.get_pipeline_status("blog_pipeline")
        assert status["status"] == "completed"
        assert status["statistics"]["total_generated"] > 0

    def test_streaming_session_management(self, streaming_service):
        """Test streaming session creation and management"""
        # Create streaming configuration
        stream_config = {
            "name": "test_stream",
            "source": "webcam",
            "platforms": ["youtube", "twitch"],
            "quality": "720p",
            "fps": 30,
        }

        # Start live stream
        result = streaming_service.start_live_stream("test_stream", stream_config)
        assert result == True

        # Check streaming status
        status = streaming_service.get_streaming_status("test_stream")
        assert status["status"] == "live"
        assert "youtube" in status["platforms"]
        assert "twitch" in status["platforms"]

        # Update stream quality
        result = streaming_service.update_stream_quality("test_stream", "1080p")
        assert result == True

        # Stop stream
        result = streaming_service.stop_live_stream("test_stream")
        assert result == True

    def test_content_scheduling(self, streaming_service):
        """Test content scheduling functionality"""
        # Create schedule configuration
        schedule_config = {
            "name": "daily_content",
            "content": "daily_update",
            "schedule_type": "daily",
            "platforms": ["youtube"],
            "hour": 9,
            "minute": 0,
        }

        # Create schedule
        result = streaming_service.schedule_content("daily_content", schedule_config)
        assert result == True

        # Check schedule status
        status = streaming_service.get_schedule_status("daily_content")
        assert status["status"] == "scheduled"
        assert status["config"]["schedule_type"] == "daily"

    def test_effect_chain_creation(self, media_processor):
        """Test effect chain creation and application"""
        # Create video effect chain
        video_effects = [
            {"type": "grayscale"},
            {"type": "blur", "params": {"kernel_size": 5}},
            {"type": "edge_detection"},
        ]

        result = media_processor.create_effect_chain("video_chain", video_effects)
        assert result == True

        # Create audio effect chain
        audio_effects = [
            {"type": "normalize"},
            {"type": "echo", "params": {"delay": 0.1, "decay": 0.5}},
        ]

        result = media_processor.create_effect_chain("audio_chain", audio_effects)
        assert result == True

        # Check effect chains
        assert "video_chain" in media_processor.effect_chains
        assert "audio_chain" in media_processor.effect_chains
        assert len(media_processor.effect_chains["video_chain"]["effects"]) == 3
        assert len(media_processor.effect_chains["audio_chain"]["effects"]) == 2

    def test_multimedia_pipeline_with_effects(self, media_processor):
        """Test multimedia pipeline with effect chains"""
        # Create effect chains first
        video_effects = [{"type": "grayscale"}]
        audio_effects = [{"type": "normalize"}]

        media_processor.create_effect_chain("test_video_chain", video_effects)
        media_processor.create_effect_chain("test_audio_chain", audio_effects)

        # Create pipeline with effects
        pipeline_config = {
            "name": "effects_pipeline",
            "type": "multimedia",
            "enable_video": True,
            "enable_audio": True,
            "video": {"device_id": 0},
            "audio": {"device_id": 0},
            "video_effects": video_effects,
            "audio_effects": audio_effects,
        }

        # Start pipeline
        result = media_processor.start_multimedia_pipeline(
            "effects_pipeline", pipeline_config
        )
        assert result == True

        # Check pipeline status
        status = media_processor.get_pipeline_status("effects_pipeline")
        assert status["status"] == "active"

        # Stop pipeline
        media_processor.stop_multimedia_pipeline("effects_pipeline")

    def test_content_quality_calculation(self, content_manager):
        """Test content quality scoring system"""
        # Test high-quality content
        high_quality_content = {
            "title": "High Quality Title",
            "description": "Comprehensive description",
            "content": "Detailed content with substantial information",
            "tags": ["tag1", "tag2", "tag3"],
            "category": "technology",
            "format": "markdown",
            "created_date": "2025-01-01T00:00:00",
        }

        quality_score = content_manager._calculate_content_quality(high_quality_content)
        assert quality_score >= 0.8

        # Test low-quality content
        low_quality_content = {
            "title": "",
            "description": "",
            "content": "",
            "tags": [],
            "category": "",
            "format": "",
            "created_date": "",
        }

        quality_score = content_manager._calculate_content_quality(low_quality_content)
        assert quality_score <= 0.3

    def test_streaming_quality_presets(self, streaming_service):
        """Test streaming quality preset management"""
        # Check available quality presets
        presets = streaming_service.streaming_config["quality_presets"]
        assert "1080p" in presets
        assert "720p" in presets
        assert "480p" in presets

        # Check preset specifications
        assert presets["1080p"]["width"] == 1920
        assert presets["1080p"]["height"] == 1080
        assert presets["1080p"]["bitrate"] == 5000

        assert presets["720p"]["width"] == 1280
        assert presets["720p"]["height"] == 720
        assert presets["720p"]["bitrate"] == 2500

    def test_content_pipeline_validation(self, content_manager):
        """Test content pipeline configuration validation"""
        # Test valid configuration
        valid_config = {
            "name": "valid_pipeline",
            "type": "blog",
            "source": "multimedia",
            "output_format": "markdown",
        }

        result = content_manager._validate_content_pipeline_config(valid_config)
        assert result == True

        # Test invalid configuration (missing required field)
        invalid_config = {
            "name": "invalid_pipeline",
            "type": "blog"
            # Missing 'source' and 'output_format'
        }

        result = content_manager._validate_content_pipeline_config(invalid_config)
        assert result == False

        # Test invalid content type
        invalid_type_config = {
            "name": "invalid_type",
            "type": "invalid_type",
            "source": "multimedia",
            "output_format": "markdown",
        }

        result = content_manager._validate_content_pipeline_config(invalid_type_config)
        assert result == False

    def test_streaming_config_validation(self, streaming_service):
        """Test streaming configuration validation"""
        # Test valid configuration
        valid_config = {
            "name": "valid_stream",
            "source": "webcam",
            "platforms": ["youtube", "twitch"],
        }

        result = streaming_service._validate_streaming_config(valid_config)
        assert result == True

        # Test invalid configuration (missing required field)
        invalid_config = {
            "name": "invalid_stream"
            # Missing 'source' and 'platforms'
        }

        result = streaming_service._validate_streaming_config(invalid_config)
        assert result == False

        # Test invalid platform
        invalid_platform_config = {
            "name": "invalid_platform",
            "source": "webcam",
            "platforms": ["invalid_platform"],
        }

        result = streaming_service._validate_streaming_config(invalid_platform_config)
        assert result == False

    def test_multimedia_system_status(self, media_processor):
        """Test overall multimedia system status reporting"""
        # Get system status
        status = media_processor.get_system_status()

        assert "system_status" in status
        assert "total_pipelines" in status
        assert "effect_chains" in status
        assert "video_service" in status
        assert "audio_service" in status
        assert "config" in status

        # Check video service status
        video_status = status["video_service"]
        assert "is_capturing" in video_status
        assert "active_captures" in video_status
        assert "devices" in video_status

        # Check audio service status
        audio_status = status["video_service"]
        assert "is_processing" in audio_status
        assert "active_streams" in audio_status
        assert "devices" in audio_status

    def test_content_cache_management(self, content_manager):
        """Test content cache operations"""
        # Check initial cache state
        cache_status = content_manager.get_content_cache()
        assert cache_status["total_cached"] == 0

        # Clear cache
        result = content_manager.clear_content_cache()
        assert result == True

        # Check cache after clearing
        cache_status = content_manager.get_content_cache()
        assert cache_status["total_cached"] == 0

    def test_streaming_statistics(self, streaming_service):
        """Test streaming statistics collection"""
        # Get streaming statistics
        stats = streaming_service.get_streaming_statistics()

        assert "total_streams" in stats
        assert "live_streams" in stats
        assert "total_viewers" in stats
        assert "total_frames_sent" in stats
        assert "total_errors" in stats
        assert "error_rate" in stats
        assert "uptime" in stats

        # Check initial values
        assert stats["total_streams"] == 0
        assert stats["live_streams"] == 0
        assert stats["total_viewers"] == 0
        assert stats["total_frames_sent"] == 0
        assert stats["total_errors"] == 0
        assert stats["error_rate"] == 0.0

    def test_error_handling(self, media_processor, content_manager, streaming_service):
        """Test error handling across all services"""
        # Test media processor error handling
        try:
            # Try to start pipeline with invalid config
            result = media_processor.start_multimedia_pipeline("error_test", {})
            assert result == False
        except Exception:
            pytest.fail("MediaProcessorService should handle invalid config gracefully")

        # Test content manager error handling
        try:
            # Try to create pipeline with invalid config
            result = content_manager.create_content_pipeline("error_test", {})
            assert result == False
        except Exception:
            pytest.fail(
                "ContentManagementService should handle invalid config gracefully"
            )

        # Test streaming service error handling
        try:
            # Try to start stream with invalid config
            result = streaming_service.start_live_stream("error_test", {})
            assert result == False
        except Exception:
            pytest.fail("StreamingService should handle invalid config gracefully")


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
