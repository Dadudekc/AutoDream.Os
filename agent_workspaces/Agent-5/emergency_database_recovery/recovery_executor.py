"""
Recovery Executor - Recovery procedures and integrity check implementation.

This module handles implementing database integrity checks and recovery procedures.
"""

import json
import logging
import os
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime

from .models import RecoveryAction, IntegrityCheckResult


class RecoveryExecutor:
    """Handles implementing recovery procedures and integrity checks."""
    
    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)
    
    def implement_integrity_checks(self, task_list_path: Path) -> Dict[str, Any]:
        """Implement database integrity checks."""
        self.logger.info("Implementing database integrity checks...")
        
        try:
            # Create integrity checker script
            script_content = self._create_integrity_checker_script()
            
            # Create backup of current task list
            backup_path = self._create_backup(task_list_path)
            
            # Run integrity checks
            integrity_results = self._run_integrity_checks(task_list_path)
            
            # Generate recovery recommendations
            recovery_actions = self._generate_recovery_recommendations(integrity_results)
            
            return {
                "integrity_checks_implemented": True,
                "backup_created": backup_path is not None,
                "backup_path": str(backup_path) if backup_path else None,
                "integrity_results": integrity_results,
                "recovery_actions": recovery_actions,
                "script_content": script_content[:500] + "..." if len(script_content) > 500 else script_content
            }
            
        except Exception as e:
            self.logger.error(f"Failed to implement integrity checks: {e}")
            return {
                "integrity_checks_implemented": False,
                "error": str(e),
                "backup_created": False,
                "integrity_results": {},
                "recovery_actions": []
            }
    
    def _create_integrity_checker_script(self) -> str:
        """Create a standalone integrity checker script."""
        script = '''#!/usr/bin/env python3
"""
Database Integrity Checker Script
Generated by Emergency Database Recovery System
"""

import json
import sys
from pathlib import Path
from datetime import datetime

def check_database_integrity(task_list_path):
    """Check database integrity and report issues."""
    try:
        with open(task_list_path, 'r') as f:
            task_list = json.load(f)
        
        contracts = task_list.get("contracts", [])
        issues = []
        
        # Check for missing required fields
        for i, contract in enumerate(contracts):
            required_fields = ["id", "title", "status", "agent"]
            missing_fields = [field for field in required_fields if field not in contract]
            
            if missing_fields:
                issues.append(f"Contract {i} missing fields: {missing_fields}")
        
        # Check for invalid status values
        valid_statuses = {"PENDING", "ACTIVE", "COMPLETED", "FAILED", "CANCELLED"}
        for i, contract in enumerate(contracts):
            status = contract.get("status")
            if status and status not in valid_statuses:
                issues.append(f"Contract {i} has invalid status: {status}")
        
        # Check for duplicate IDs
        contract_ids = set()
        for i, contract in enumerate(contracts):
            contract_id = contract.get("id")
            if contract_id in contract_ids:
                issues.append(f"Duplicate contract ID: {contract_id}")
            contract_ids.add(contract_id)
        
        if issues:
            print(f"Found {len(issues)} integrity issues:")
            for issue in issues:
                print(f"  - {issue}")
            return False
        else:
            print("Database integrity verified - no issues found")
            return True
            
    except Exception as e:
        print(f"Integrity check failed: {e}")
        return False

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python integrity_checker.py <task_list_path>")
        sys.exit(1)
    
    task_list_path = Path(sys.argv[1])
    if not task_list_path.exists():
        print(f"Error: {task_list_path} does not exist")
        sys.exit(1)
    
    success = check_database_integrity(task_list_path)
    sys.exit(0 if success else 1)
'''
        return script
    
    def _create_backup(self, task_list_path: Path) -> Optional[Path]:
        """Create a backup of the current task list."""
        try:
            if not task_list_path.exists():
                return None
            
            # Create backup directory
            backup_dir = task_list_path.parent / "backups"
            backup_dir.mkdir(exist_ok=True)
            
            # Create backup filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"task_list_backup_{timestamp}.json"
            backup_path = backup_dir / backup_filename
            
            # Copy file
            import shutil
            shutil.copy2(task_list_path, backup_path)
            
            self.logger.info(f"Backup created: {backup_path}")
            return backup_path
            
        except Exception as e:
            self.logger.error(f"Failed to create backup: {e}")
            return None
    
    def _run_integrity_checks(self, task_list_path: Path) -> Dict[str, Any]:
        """Run integrity checks on the database."""
        try:
            with open(task_list_path, 'r') as f:
                task_list = json.load(f)
            
            contracts = task_list.get("contracts", [])
            
            # Basic integrity checks
            total_contracts = len(contracts)
            valid_contracts = 0
            invalid_contracts = 0
            issues = []
            
            for i, contract in enumerate(contracts):
                try:
                    # Check required fields
                    required_fields = ["id", "title", "status", "agent"]
                    if all(field in contract for field in required_fields):
                        valid_contracts += 1
                    else:
                        invalid_contracts += 1
                        issues.append(f"Contract {i} missing required fields")
                except Exception as e:
                    invalid_contracts += 1
                    issues.append(f"Contract {i} validation error: {str(e)}")
            
            return {
                "total_contracts": total_contracts,
                "valid_contracts": valid_contracts,
                "invalid_contracts": invalid_contracts,
                "issues": issues,
                "integrity_score": (valid_contracts / total_contracts * 100) if total_contracts > 0 else 0
            }
            
        except Exception as e:
            return {
                "error": str(e),
                "total_contracts": 0,
                "valid_contracts": 0,
                "invalid_contracts": 0,
                "issues": [f"Failed to run integrity checks: {str(e)}"],
                "integrity_score": 0
            }
    
    def _generate_recovery_recommendations(self, integrity_results: Dict[str, Any]) -> List[RecoveryAction]:
        """Generate recovery recommendations based on integrity check results."""
        recommendations = []
        
        if "error" in integrity_results:
            recommendations.append(RecoveryAction(
                action_id="fix_integrity_checker",
                priority=1,
                description="Fix integrity checker system error",
                affected_components=["integrity_checker"],
                estimated_time=30,
                status="PENDING"
            ))
            return recommendations
        
        integrity_score = integrity_results.get("integrity_score", 0)
        invalid_contracts = integrity_results.get("invalid_contracts", 0)
        
        if integrity_score < 50:
            recommendations.append(RecoveryAction(
                action_id="emergency_database_repair",
                priority=1,
                description="Emergency database repair required",
                affected_components=["database"],
                estimated_time=120,
                status="PENDING"
            ))
        elif integrity_score < 80:
            recommendations.append(RecoveryAction(
                action_id="database_maintenance",
                priority=2,
                description="Database maintenance and cleanup required",
                affected_components=["database"],
                estimated_time=60,
                status="PENDING"
            ))
        
        if invalid_contracts > 0:
            recommendations.append(RecoveryAction(
                action_id="fix_invalid_contracts",
                priority=3,
                description=f"Fix {invalid_contracts} invalid contracts",
                affected_components=["contracts"],
                estimated_time=invalid_contracts * 5,  # 5 minutes per contract
                status="PENDING"
            ))
        
        # Always recommend regular integrity monitoring
        recommendations.append(RecoveryAction(
            action_id="implement_monitoring",
            priority=4,
            description="Implement regular integrity monitoring",
            affected_components=["monitoring"],
            estimated_time=45,
            status="PENDING"
        ))
        
        return recommendations
    
    def execute_recovery_action(self, action: RecoveryAction, task_list_path: Path) -> Dict[str, Any]:
        """Execute a specific recovery action."""
        self.logger.info(f"Executing recovery action: {action.description}")
        
        try:
            if action.action_id == "emergency_database_repair":
                return self._execute_emergency_repair(task_list_path)
            elif action.action_id == "fix_invalid_contracts":
                return self._execute_contract_repair(task_list_path)
            elif action.action_id == "database_maintenance":
                return self._execute_database_maintenance(task_list_path)
            else:
                return {
                    "action_executed": False,
                    "error": f"Unknown action: {action.action_id}",
                    "action_id": action.action_id
                }
                
        except Exception as e:
            self.logger.error(f"Failed to execute recovery action: {e}")
            return {
                "action_executed": False,
                "error": str(e),
                "action_id": action.action_id
            }
    
    def _execute_emergency_repair(self, task_list_path: Path) -> Dict[str, Any]:
        """Execute emergency database repair."""
        try:
            # Create emergency backup
            backup_path = self._create_backup(task_list_path)
            
            # Load current data
            with open(task_list_path, 'r') as f:
                task_list = json.load(f)
            
            contracts = task_list.get("contracts", [])
            repaired_contracts = 0
            
            # Attempt to repair critical issues
            for contract in contracts:
                # Fix missing required fields with defaults
                if "id" not in contract:
                    contract["id"] = f"EMERGENCY_ID_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                    repaired_contracts += 1
                
                if "status" not in contract:
                    contract["status"] = "PENDING"
                    repaired_contracts += 1
                
                if "agent" not in contract:
                    contract["agent"] = "UNASSIGNED"
                    repaired_contracts += 1
                
                if "title" not in contract:
                    contract["title"] = "Untitled Contract"
                    repaired_contracts += 1
            
            # Save repaired data
            with open(task_list_path, 'w') as f:
                json.dump(task_list, f, indent=2)
            
            return {
                "action_executed": True,
                "action_id": "emergency_database_repair",
                "backup_created": backup_path is not None,
                "contracts_repaired": repaired_contracts,
                "total_contracts": len(contracts)
            }
            
        except Exception as e:
            return {
                "action_executed": False,
                "error": str(e),
                "action_id": "emergency_database_repair"
            }
    
    def _execute_contract_repair(self, task_list_path: Path) -> Dict[str, Any]:
        """Execute contract repair."""
        try:
            with open(task_list_path, 'r') as f:
                task_list = json.load(f)
            
            contracts = task_list.get("contracts", [])
            repaired_contracts = 0
            
            for contract in contracts:
                # Fix common contract issues
                if self._repair_contract(contract):
                    repaired_contracts += 1
            
            # Save repaired data
            with open(task_list_path, 'w') as f:
                json.dump(task_list, f, indent=2)
            
            return {
                "action_executed": True,
                "action_id": "fix_invalid_contracts",
                "contracts_repaired": repaired_contracts,
                "total_contracts": len(contracts)
            }
            
        except Exception as e:
            return {
                "action_executed": False,
                "error": str(e),
                "action_id": "fix_invalid_contracts"
            }
    
    def _execute_database_maintenance(self, task_list_path: Path) -> Dict[str, Any]:
        """Execute database maintenance."""
        try:
            # Create maintenance backup
            backup_path = self._create_backup(task_list_path)
            
            # Load current data
            with open(task_list_path, 'r') as f:
                task_list = json.load(f)
            
            # Clean up metadata
            if "metadata" not in task_list:
                task_list["metadata"] = {}
            
            # Update contract count
            contracts = task_list.get("contracts", [])
            task_list["metadata"]["total_contracts"] = len(contracts)
            task_list["metadata"]["last_maintenance"] = datetime.now().isoformat()
            
            # Save maintained data
            with open(task_list_path, 'w') as f:
                json.dump(task_list, f, indent=2)
            
            return {
                "action_executed": True,
                "action_id": "database_maintenance",
                "backup_created": backup_path is not None,
                "maintenance_completed": True
            }
            
        except Exception as e:
            return {
                "action_executed": False,
                "error": str(e),
                "action_id": "database_maintenance"
            }
    
    def _repair_contract(self, contract: Dict[str, Any]) -> bool:
        """Repair a single contract."""
        repaired = False
        
        # Fix invalid status values
        status = contract.get("status")
        valid_statuses = {"PENDING", "ACTIVE", "COMPLETED", "FAILED", "CANCELLED"}
        if status and status not in valid_statuses:
            contract["status"] = "PENDING"
            repaired = True
        
        # Fix negative numeric values
        numeric_fields = ["points", "estimated_hours", "actual_hours"]
        for field in numeric_fields:
            value = contract.get(field)
            if isinstance(value, (int, float)) and value < 0:
                contract[field] = abs(value)
                repaired = True
        
        # Fix empty string fields
        string_fields = ["title", "description"]
        for field in string_fields:
            value = contract.get(field)
            if value is not None and isinstance(value, str) and not value.strip():
                if field == "title":
                    contract[field] = "Untitled Contract"
                else:
                    contract[field] = "No description provided"
                repaired = True
        
        return repaired
