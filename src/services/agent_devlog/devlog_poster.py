#!/usr/bin/env python3
"""
Agent Devlog Poster
===================

Main devlog posting service for Agent Devlog Posting Service
V2 Compliant: ≤400 lines, focused posting logic
"""

import asyncio
import logging
import os
from datetime import datetime
from typing import Any

from .agent_validation import AgentValidator
from src.shared.models import DevlogEntry, DevlogStatus
from .storage import DevlogStorage


class AgentDevlogPoster:
    """Agent devlog posting service with LOCAL FILE storage AND Discord integration"""

    def __init__(self, devlogs_dir: str = "devlogs"):
        """Initialize agent devlog poster"""
        self.storage = DevlogStorage(devlogs_dir)
        self.validator = AgentValidator()

        # Configure logging
        logging.basicConfig(
            level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        self.logger = logging.getLogger(__name__)

        self.logger.info(
            "AgentDevlogPoster initialized - Local file storage AND Discord integration"
        )

    def create_devlog_content(
        self, agent_flag: str, action: str, status: str = "completed", details: str = ""
    ) -> str:
        """Create formatted devlog content for local file storage"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")
        agent_info = self.validator.get_agent_info(agent_flag)

        content = f"""# 🤖 Agent Devlog - {agent_flag}

## 📅 Timestamp
{timestamp}

## 🎯 Agent Information
- **Agent ID:** {agent_flag}
- **Role:** {agent_info.get('role', 'Specialist') if agent_info else 'Specialist'}
- **Status:** {status}

## 📝 Action Details
**Action:** {action}

## 📊 Status
**Status:** {status}

## 🔧 Technical Details
- **Devlog Type:** Agent Action
- **Posting Method:** Local File Storage
- **Storage Type:** JSON File
- **Timestamp:** {timestamp}

## 📋 Additional Details
{details if details else "No additional details provided"}

## 🐝 Swarm Coordination
- **System:** Agent Devlog Posting Service
- **Storage:** Local File System
- **Format:** JSON
- **Backup:** Enabled

---
*Generated by Agent Devlog Posting Service - Local Storage Only*
"""

        return content

    def post_to_discord(self, content: str, agent_id: str) -> bool:
        """Post devlog content to Discord."""
        try:
            # Check if SSOT routing is enabled
            use_manager = os.getenv("DEVLOG_POST_VIA_MANAGER", "false").lower() == "true"

            if use_manager:
                # Use SSOT client (Discord Manager routing)
                return self._post_to_discord_via_manager(content, agent_id)
            else:
                # Use legacy Discord service (current behavior)
                return self._post_to_discord_via_legacy(content, agent_id)

        except Exception as e:
            self.logger.error(f"Discord posting failed: {e}")
            return False

    def _post_to_discord_via_manager(self, content: str, agent_id: str) -> bool:
        """Post devlog content via Discord Manager SSOT."""
        try:
            # Import SSOT client
            from src.services.discord_commander.discord_post_client import post_devlog_via_ssot

            self.logger.info(f"🔄 Using SSOT Discord Manager routing for {agent_id}")

            # Post via SSOT (asynchronous)
            result = asyncio.run(post_devlog_via_ssot(agent_id, content))

            if result:
                self.logger.info(f"✅ Devlog posted via SSOT for {agent_id}")
            else:
                self.logger.warning(f"⚠️ SSOT posting failed for {agent_id}")

            return result

        except Exception as e:
            self.logger.error(f"SSOT posting failed: {e}")
            return False

    def _post_to_discord_via_legacy(self, content: str, agent_id: str) -> bool:
        """Post devlog content via legacy Discord service with webhook fallback."""
        try:
            # Import Discord service
            from src.services.discord_devlog_service import DiscordDevlogService

            # Initialize Discord service
            discord_service = DiscordDevlogService()

            # Post to Discord using synchronous wrapper
            result = self._post_to_discord_sync(discord_service, content, agent_id)

            # If legacy service fails, try webhook fallback
            if not result:
                self.logger.info(
                    f"Legacy Discord service failed, trying webhook fallback for {agent_id}"
                )
                result = self._post_to_discord_via_webhook_fallback(content, agent_id)

            return result

        except Exception as e:
            self.logger.error(f"Legacy Discord posting failed: {e}")
            # Try webhook fallback on exception
            self.logger.info(f"Trying webhook fallback for {agent_id}")
            return self._post_to_discord_via_webhook_fallback(content, agent_id)

    def _post_to_discord_sync(self, discord_service, content: str, agent_id: str) -> bool:
        """Synchronous wrapper for Discord posting."""
        try:
            # Create new event loop for this operation
            import threading

            result = [False]  # Use list to allow modification in nested function

            def run_async():
                try:
                    # Create new event loop in thread
                    new_loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(new_loop)

                    # Run the async function
                    result[0] = new_loop.run_until_complete(
                        discord_service.post_devlog_to_discord(content, agent_id)
                    )

                    new_loop.close()
                except Exception as e:
                    self.logger.error(f"Async Discord posting failed: {e}")
                    result[0] = False

            # Run in separate thread to avoid event loop conflicts
            thread = threading.Thread(target=run_async, daemon=True)
            thread.start()
            thread.join(timeout=10)  # 10 second timeout

            if thread.is_alive():
                self.logger.warning("Discord posting timed out")
                return False

            return result[0]

        except Exception as e:
            self.logger.error(f"Sync Discord posting failed: {e}")
            return False

    def _post_to_discord_via_webhook_fallback(self, content: str, agent_id: str) -> bool:
        """Post devlog content via webhook fallback when Discord service fails."""
        try:
            from pathlib import Path

            # Load webhook URL from .env
            env_file = Path(".env")
            webhook_url = None
            if env_file.exists():
                with open(env_file) as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith("#") and "=" in line:
                            key, value = line.split("=", 1)
                            value = value.strip("\"'")
                            os.environ[key] = value
                            if key == "DISCORD_WEBHOOK_URL":
                                webhook_url = value

            if not webhook_url:
                self.logger.warning("No webhook URL available for fallback")
                return False

            # Format message with minimal spam filtering
            discord_message = self._format_discord_message_simple(content, agent_id)
            if discord_message is None:
                self.logger.info(f"Spam filter triggered for webhook fallback: {agent_id}")
                return False

            # Create payload
            payload = {
                "content": discord_message,
                "username": f"{agent_id}" if agent_id else "Agent Devlog System",
            }

            # Post to webhook synchronously
            import requests

            response = requests.post(webhook_url, json=payload, timeout=10)

            if response.status_code == 204:
                self.logger.info(f"✅ Webhook fallback successful for {agent_id}")
                return True
            else:
                self.logger.error(f"Webhook fallback failed with status {response.status_code}")
                return False

        except Exception as e:
            self.logger.error(f"Webhook fallback failed: {e}")
            return False

    def _format_discord_message_simple(self, content: str, agent_id: str = None) -> str:
        """Format message for Discord with minimal spam filtering."""
        # MINIMAL SPAM FILTER: Only block extreme patterns
        if "📝 DISCORD DEVLOG REMINDER:" in content and content.count("📝") > 3:
            return None  # Block only excessive reminder spam

        # Extract action and status
        lines = content.split("\n")
        action = "Agent Communication"
        status = "Communication Active"

        for line in lines:
            if "**Action:**" in line:
                action = line.split("**Action:**")[-1].strip()
            elif "Action:" in line:
                action = line.split("Action:")[-1].strip()

            if "**Status:**" in line:
                status = line.split("**Status:**")[-1].strip()
            elif "- **Status:**" in line:
                status = line.split("- **Status:**")[-1].strip()
            elif "Status:" in line:
                status = line.split("Status:")[-1].strip()

        # Create Discord message
        timestamp = datetime.now().strftime("%H:%M:%S")
        discord_message = f"""🤖 **{agent_id or 'Agent'}**: {action}
Status: {status} | {timestamp}

🐝 *Devlog Service*"""

        return discord_message

    def post_devlog(
        self,
        agent_flag: str,
        action: str,
        status: str = "completed",
        details: str = "",
        dry_run: bool = False,
    ) -> dict[str, Any]:
        """Post devlog entry"""
        # Validate agent flag
        if not self.validator.validate_agent_flag(agent_flag):
            return {
                "success": False,
                "error": f"Invalid agent flag: {agent_flag}. Must be Agent-1 through Agent-8",
            }

        # Validate action
        if not self.validator.validate_action(action):
            return {"success": False, "error": "Invalid action. Must be 3-500 characters long"}

        # Validate status
        if not self.validator.validate_status(status):
            return {
                "success": False,
                "error": f"Invalid status: {status}. Must be one of: completed, in_progress, failed, pending",
            }

        # Validate details
        if not self.validator.validate_details(details):
            return {"success": False, "error": "Details too long. Maximum 2000 characters allowed"}

        # Create devlog entry
        timestamp = datetime.now().isoformat()
        devlog_type = self.validator.suggest_devlog_type(action, status)

        devlog_entry = DevlogEntry(
            agent_id=agent_flag,
            action=action,
            status=DevlogStatus(status),
            message=action,  # Use action as message
            details=details,
            timestamp=timestamp,
            devlog_type=devlog_type,
            metadata={"posting_method": "local_file", "storage_type": "json", "dry_run": dry_run},
        )

        if dry_run:
            return {
                "success": True,
                "message": "Dry run completed successfully",
                "devlog_entry": {
                    "agent_id": devlog_entry.agent_id,
                    "action": devlog_entry.action,
                    "status": devlog_entry.status.value,
                    "details": devlog_entry.details,
                    "timestamp": devlog_entry.timestamp,
                    "devlog_type": devlog_entry.devlog_type.value,
                },
            }

        # Save devlog
        success = self.storage.save_devlog(devlog_entry)

        if success:
            # Also post to Discord
            discord_success = self.post_to_discord(
                self.create_devlog_content(agent_flag, action, status, details), agent_flag
            )

            self.logger.info(f"✅ Devlog posted successfully for {agent_flag}")
            if discord_success:
                self.logger.info(f"✅ Devlog posted to Discord for {agent_flag}")
            else:
                self.logger.warning(f"⚠️ Discord posting failed for {agent_flag}")

            return {
                "success": True,
                "message": f"Devlog posted successfully for {agent_flag}",
                "agent_id": agent_flag,
                "action": action,
                "status": status,
                "timestamp": timestamp,
                "discord_posted": discord_success,
            }
        else:
            return {"success": False, "error": "Failed to save devlog to file"}

    def search_devlogs(
        self,
        query: str,
        agent_id: str | None = None,
        status: str | None = None,
        limit: int = 50,
    ) -> dict[str, Any]:
        """Search devlogs"""
        try:
            results = self.storage.search_devlogs(query, agent_id, status, limit)

            return {
                "success": True,
                "query": query,
                "results": results,
                "total_matches": len(results),
                "filters": {"agent_id": agent_id, "status": status, "limit": limit},
            }
        except Exception as e:
            return {"success": False, "error": str(e), "query": query}

    def get_devlog_stats(self) -> dict[str, Any]:
        """Get devlog statistics"""
        try:
            stats = self.storage.get_devlog_stats()
            file_info = self.storage.get_file_info()

            return {
                "success": True,
                "stats": {
                    "total_devlogs": stats.total_devlogs,
                    "agent_counts": stats.agent_counts,
                    "status_counts": stats.status_counts,
                    "type_counts": stats.type_counts,
                    "recent_activity": stats.recent_activity,
                },
                "file_info": file_info,
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    def cleanup_old_devlogs(self, days_to_keep: int = 30) -> dict[str, Any]:
        """Cleanup old devlog files"""
        try:
            deleted_count = self.storage.cleanup_old_files(days_to_keep)

            return {
                "success": True,
                "message": f"Cleaned up {deleted_count} old devlog files",
                "deleted_files": deleted_count,
                "days_kept": days_to_keep,
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    def get_agent_info(self, agent_id: str) -> dict[str, Any]:
        """Get agent information"""
        agent_info = self.validator.get_agent_info(agent_id)

        if agent_info:
            return {
                "success": True,
                "agent_info": {
                    "agent_id": agent_info.agent_id,
                    "role": agent_info.role,
                    "status": agent_info.status,
                    "capabilities": agent_info.capabilities,
                    "is_captain": self.validator.is_captain_agent(agent_id),
                },
            }
        else:
            return {"success": False, "error": f"Invalid agent ID: {agent_id}"}

    def get_all_agents(self) -> dict[str, Any]:
        """Get all agents information"""
        agents = self.validator.get_all_agents()
        agent_stats = self.validator.get_agent_statistics()

        return {
            "success": True,
            "agents": agents,
            "agent_stats": agent_stats,
            "total_agents": len(agents),
        }
