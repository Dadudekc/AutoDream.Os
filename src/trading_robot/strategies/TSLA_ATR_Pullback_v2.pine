//@version=5
strategy("FORGE MODE: TSLA ATR Pullback v2", overlay=true,
     initial_capital=100000, pyramiding=0,
     commission_type=strategy.commission.percent, commission_value=0.02, // ~2 bps realistic
     slippage=1, calc_on_order_fills=true, calc_on_every_tick=true, process_orders_on_close=true)

//========================= Inputs
riskPercent   = input.float(0.5,  "Risk % per trade",  minval=0.1, maxval=5.0, step=0.1)
atrMult       = input.float(2.0,  "ATR stop multiplier", minval=1.0, maxval=5.0, step=0.1)
rrRatio       = input.float(2.0,  "Risk:Reward (fixed TP)", minval=1.0, maxval=5.0, step=0.1)
maShortLen    = input.int(20,     "MA Short", minval=2)
maLongLen     = input.int(50,     "MA Long",  minval=5)
rsiPeriod     = input.int(14,     "RSI Period")
rsiOB         = input.int(70,     "RSI Overbought")
rsiOS         = input.int(30,     "RSI Oversold")
cooldownBars  = input.int(5,      "Cooldown bars after flat", minval=0)

useTrail      = input.bool(false, "Use Trailing Stop (else Fixed TP/SL)")
trailK        = input.float(1.0,  "Trail Dist = ATR * K", minval=0.1, step=0.1)

useRTH        = input.bool(true, "Trade Regular Session Only (NYSE 09:30â€“16:00)")
sessInp       = input.session("0930-1600", "Session (exchange time)")
volGate       = input.bool(true, "Require min volatility (ATR/Close)")
minVol        = input.float(0.004, "Min ATR/Close (0.004 = 0.4%)", step=0.0001)

//========================= Indicators
maS  = ta.sma(close, maShortLen)
maL  = ta.sma(close, maLongLen)
rsi  = ta.rsi(close, rsiPeriod)
atr  = ta.atr(14)

inSess = not na(time(timeframe.period, sessInp))
volOK  = (atr/close) >= minVol or not volGate

trendUp = maS > maL
trendDn = maS < maL

// Event-based signals
longSig  = trendUp and close > maS and ta.crossover(rsi, rsiOS)
shortSig = trendDn and close < maS and ta.crossunder(rsi, rsiOB)

//========================= Cooldown
var int  lastExitBar = na
flatNow   = strategy.position_size == 0
flatPrev  = strategy.position_size[1] == 0
justClosed = not flatPrev and flatNow
if justClosed
    lastExitBar := bar_index

coolOK = na(lastExitBar) or (bar_index - lastExitBar >= cooldownBars)
canTrade = (not useRTH or inSess) and volOK and coolOK

//========================= Trade constants per entry
var float stopDistAtEntry = na
var int   posDir = 0   // +1 long, -1 short

risk$      = strategy.equity * (riskPercent/100)
stopDist   = atr * atrMult
qtyRaw     = risk$ / (stopDist * syminfo.pointvalue)
qty        = math.max(1.0, qtyRaw)  // allow fractional; change to floor if you want integer shares

newLong  = longSig  and flatNow and canTrade
newShort = shortSig and flatNow and canTrade

if newLong
    stopDistAtEntry := stopDist
    posDir := 1
    strategy.entry("Long", strategy.long, qty=qty)

if newShort
    stopDistAtEntry := stopDist
    posDir := -1
    strategy.entry("Short", strategy.short, qty=qty)

//========================= Per-bar exits (anchored to avg price)
inLong  = strategy.position_size > 0
inShort = strategy.position_size < 0
havePos = not flatNow and not na(stopDistAtEntry)

if havePos
    entry = strategy.position_avg_price
    longStop   = entry - stopDistAtEntry
    longTake   = entry + stopDistAtEntry * rrRatio
    shortStop  = entry + stopDistAtEntry
    shortTake  = entry - stopDistAtEntry * rrRatio

    if useTrail
        // Price units (no mintick conversion!)
        if inLong
            strategy.exit("L-Exit", from_entry="Long",
                trail_points=stopDistAtEntry*trailK, trail_offset=stopDistAtEntry*trailK)
        if inShort
            strategy.exit("S-Exit", from_entry="Short",
                trail_points=stopDistAtEntry*trailK, trail_offset=stopDistAtEntry*trailK)
    else
        if inLong
            strategy.exit("L-Exit", from_entry="Long", stop=longStop,  limit=longTake)
        if inShort
            strategy.exit("S-Exit", from_entry="Short", stop=shortStop, limit=shortTake)

// Reset caches when flat
if flatNow
    stopDistAtEntry := na
    posDir := 0

//========================= Plots
plot(maS, "MA Short", color=color.new(color.blue, 0))
plot(maL, "MA Long",  color=color.new(color.red,  0))

entryPlot = havePos ? strategy.position_avg_price : na
plot(entryPlot, "Entry", color=color.new(color.green, 0), linewidth=2)

longStopP  = inLong  and havePos ? strategy.position_avg_price - stopDistAtEntry : na
longTakeP  = inLong  and havePos ? strategy.position_avg_price + stopDistAtEntry*rrRatio : na
shortStopP = inShort and havePos ? strategy.position_avg_price + stopDistAtEntry : na
shortTakeP = inShort and havePos ? strategy.position_avg_price - stopDistAtEntry*rrRatio : na

plot(longStopP,  "L Stop", color=color.new(color.red,   30))
plot(longTakeP,  "L Take", color=color.new(color.green, 30))
plot(shortStopP, "S Stop", color=color.new(color.red,   30))
plot(shortTakeP, "S Take", color=color.new(color.green, 30))

// RSI helpers (hidden pane)
plot(rsi, "RSI", color=color.purple, display=display.none)
hline(rsiOB, "RSI Overbought", color=color.red)
hline(rsiOS, "RSI Oversold",   color=color.green)
hline(50,    "RSI Mid",        color=color.gray)

// Alerts
alertcondition(longSig,  "Long Signal",  "Long entry signal triggered")
alertcondition(shortSig, "Short Signal", "Short entry signal triggered")
