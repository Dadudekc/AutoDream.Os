#!/usr/bin/env python3
"""
Enhanced Utils Function Catalog Generator
=========================================

Generates a comprehensive catalog of functions, classes, and exports
in all utils directories with enhanced metadata.

V2 Compliant: ≤300 lines, single responsibility, type hints.

Features:
- Top-level functions and classes
- Module exports (__all__ declarations)
- Re-exported symbols from imports
- Module docstrings
- Line counts for V2 compliance tracking
- Enhanced formatting and organization

Author: Agent-3 (Infrastructure & DevOps Specialist)
License: MIT
"""

import ast
from pathlib import Path
from typing import Dict, List, Tuple, Set, Optional


class UtilsAnalyzer:
    """Analyzer for Python files in utils directories."""

    def __init__(self, root_path: Path):
        """Initialize analyzer with project root path."""
        self.root = root_path
        self.entries: List[Dict] = []

    def analyze_file(self, py_file: Path) -> Dict:
        """Analyze a single Python file."""
        rel_path = py_file.relative_to(self.root)
        
        # Count lines
        try:
            with py_file.open("r", encoding="utf-8") as f:
                content = f.read()
                line_count = len(content.splitlines())
        except Exception:
            line_count = 0

        # Parse AST
        try:
            with py_file.open("r", encoding="utf-8") as f:
                tree = ast.parse(f.read(), filename=str(py_file))
        except SyntaxError:
            return {
                'path': str(rel_path),
                'line_count': line_count,
                'error': 'Syntax Error',
                'functions': [],
                'classes': [],
                'exports': [],
                'imports': [],
                'docstring': None
            }

        # Extract components
        functions = []
        classes = []
        exports = []
        imports = []
        docstring = ast.get_docstring(tree)

        for node in tree.body:
            if isinstance(node, ast.FunctionDef):
                functions.append(node.name)
            elif isinstance(node, ast.ClassDef):
                classes.append(node.name)
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    for alias in node.names:
                        imports.append(f"{node.module}.{alias.name}")
                else:
                    for alias in node.names:
                        imports.append(alias.name)
            elif isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name) and target.id == '__all__':
                        if isinstance(node.value, (ast.List, ast.Tuple)):
                            exports = [
                                elt.s for elt in node.value.elts 
                                if isinstance(elt, ast.Str)
                            ] or [
                                elt.value for elt in node.value.elts 
                                if isinstance(elt, ast.Constant) and isinstance(elt.value, str)
                            ]

        return {
            'path': str(rel_path),
            'line_count': line_count,
            'functions': sorted(functions),
            'classes': sorted(classes),
            'exports': sorted(exports),
            'imports': imports[:5],  # Limit for brevity
            'docstring': docstring.split('\n')[0] if docstring else None
        }

    def scan_utils_directories(self):
        """Scan all Python files in utils directories."""
        for py_file in self.root.rglob("*.py"):
            if "utils" not in py_file.parts:
                continue
            # Skip pycache and backups
            if "__pycache__" in py_file.parts or "backups" in py_file.parts:
                continue
            
            entry = self.analyze_file(py_file)
            self.entries.append(entry)

    def generate_markdown(self) -> str:
        """Generate markdown documentation."""
        lines = [
            "# Enhanced Utils Function Catalog",
            "",
            "Comprehensive catalog of utilities across the project.",
            "",
            "**Generated by:** Agent-3 (Infrastructure & DevOps Specialist)",
            "**Purpose:** Infrastructure monitoring and V2 compliance tracking",
            "",
            "---",
            "",
            "## 📊 Summary Statistics",
            "",
        ]

        # Calculate statistics
        total_files = len(self.entries)
        total_functions = sum(len(e['functions']) for e in self.entries)
        total_classes = sum(len(e['classes']) for e in self.entries)
        total_lines = sum(e['line_count'] for e in self.entries)
        v2_compliant = sum(1 for e in self.entries if e['line_count'] <= 400)
        v2_violations = total_files - v2_compliant

        lines.extend([
            f"- **Total Files:** {total_files}",
            f"- **Total Functions:** {total_functions}",
            f"- **Total Classes:** {total_classes}",
            f"- **Total Lines:** {total_lines:,}",
            f"- **V2 Compliant (≤400 lines):** {v2_compliant} ({v2_compliant/total_files*100:.1f}%)",
            f"- **V2 Violations (>400 lines):** {v2_violations}",
            "",
            "---",
            "",
            "## 📁 File Catalog",
            "",
        ])

        # Sort entries by path
        for entry in sorted(self.entries, key=lambda e: e['path']):
            path = entry['path']
            line_count = entry['line_count']
            
            # V2 compliance indicator
            if line_count <= 400:
                v2_badge = "✅"
            elif line_count <= 600:
                v2_badge = "⚠️"
            else:
                v2_badge = "❌"

            lines.append(f"### {v2_badge} `{path}` ({line_count} lines)")
            lines.append("")

            # Docstring
            if entry.get('docstring'):
                lines.append(f"**Description:** {entry['docstring']}")
                lines.append("")

            # Functions
            if entry['functions']:
                funcs_str = ", ".join(f"`{f}`" for f in entry['functions'])
                lines.append(f"**Functions:** {funcs_str}")
                lines.append("")

            # Classes
            if entry['classes']:
                classes_str = ", ".join(f"`{c}`" for c in entry['classes'])
                lines.append(f"**Classes:** {classes_str}")
                lines.append("")

            # Exports
            if entry['exports']:
                exports_str = ", ".join(f"`{e}`" for e in entry['exports'])
                lines.append(f"**Exports:** {exports_str}")
                lines.append("")

            # Error indicator
            if entry.get('error'):
                lines.append(f"**⚠️ Error:** {entry['error']}")
                lines.append("")

            lines.append("---")
            lines.append("")

        # V2 Compliance Section
        violations = [e for e in self.entries if e['line_count'] > 400]
        if violations:
            lines.extend([
                "## ⚠️ V2 Compliance Violations",
                "",
                "Files exceeding 400-line limit:",
                "",
            ])
            for entry in sorted(violations, key=lambda e: -e['line_count']):
                lines.append(
                    f"- **{entry['path']}:** {entry['line_count']} lines "
                    f"({entry['line_count'] - 400} over limit)"
                )
            lines.append("")

        return "\n".join(lines)


def main():
    """Main execution function."""
    root = Path(__file__).resolve().parent.parent
    analyzer = UtilsAnalyzer(root)
    
    print("🔍 Scanning utils directories...")
    analyzer.scan_utils_directories()
    
    print(f"📊 Analyzed {len(analyzer.entries)} files")
    
    print("📝 Generating enhanced catalog...")
    markdown_content = analyzer.generate_markdown()
    
    output_path = root / "docs" / "utils_function_catalog_enhanced.md"
    output_path.write_text(markdown_content, encoding="utf-8")
    
    print(f"✅ Enhanced catalog saved to: {output_path}")
    print("")
    print("🐝 WE. ARE. SWARM. ⚡⚡🔥🔥")


if __name__ == '__main__':
    main()

